<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>The Prism — Senshin-dō (A-Frame)</title>
  <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'JetBrains Mono', monospace;
      background: #0a0a0a;
      color: #e0e0e0;
      overflow: hidden;
    }

    /* Control Panel */
    .control-panel {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 100;
      background: rgba(0, 0, 0, 0.85);
      border: 1px solid #333;
      padding: 20px;
      min-width: 280px;
      max-width: calc(100vw - 40px);
    }

    .slider-container label {
      display: block;
      font-size: 0.7rem;
      letter-spacing: 0.2em;
      color: #666;
      margin-bottom: 8px;
    }

    input[type="range"] {
      width: 100%;
      height: 4px;
      -webkit-appearance: none;
      background: linear-gradient(to right, #444, #0ff, #f00);
      border-radius: 0;
      outline: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: #fff;
      border: 2px solid #000;
      cursor: pointer;
    }

    .slider-labels {
      display: flex;
      justify-content: space-between;
      font-size: 0.6rem;
      color: #555;
      margin-top: 4px;
    }

    .readout {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid #222;
      display: flex;
      justify-content: space-between;
      font-size: 0.7rem;
    }

    .time { color: #0ff; }
    .location { color: #666; }

    /* Info Panel */
    .info-panel {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 360px;
      max-width: calc(100vw - 40px);
      background: rgba(0, 0, 0, 0.9);
      border: 1px solid #333;
      transform: translateY(120%);
      transition: transform 0.3s ease;
      z-index: 100;
    }

    .info-panel.open {
      transform: translateY(0);
    }

    .info-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      border-bottom: 1px solid #333;
    }

    .info-title {
      font-size: 0.8rem;
      letter-spacing: 0.1em;
    }

    .info-close {
      background: none;
      border: none;
      color: #666;
      font-size: 1.2rem;
      cursor: pointer;
    }

    .info-content {
      padding: 16px;
      font-size: 0.75rem;
      line-height: 1.6;
    }

    .info-content p {
      margin-bottom: 12px;
      padding-left: 12px;
      border-left: 2px solid transparent;
      transition: opacity 0.3s, border-color 0.3s;
    }

    .skeleton-content { border-left-color: #666; }
    .blueprint-content { border-left-color: #0ff; }
    .ghost-content { border-left-color: #f44; }

    /* Layer visibility based on reality index */
    .skeleton-content { opacity: calc(1 - var(--reality, 0)); }
    .blueprint-content {
      opacity: calc(1 - abs(var(--reality, 0) - 0.5) * 2);
    }
    .ghost-content { opacity: var(--reality, 0); }

    /* Resonance text */
    .resonance {
      position: fixed;
      bottom: 50%;
      left: 50%;
      transform: translate(-50%, 50%);
      text-align: center;
      font-size: 1rem;
      font-style: italic;
      color: rgba(255, 68, 68, 0);
      transition: color 0.5s ease;
      pointer-events: none;
      z-index: 50;
      max-width: 500px;
    }

    .resonance.visible {
      color: rgba(255, 68, 68, 0.8);
    }

    /* A-Frame scene container */
    .scene-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    a-scene {
      width: 100%;
      height: 100%;
    }

    /* Layer indicator */
    .layer-indicator {
      position: fixed;
      top: 20px;
      right: 20px;
      font-size: 0.7rem;
      letter-spacing: 0.2em;
      z-index: 100;
      white-space: nowrap;
      display: flex;
      gap: 0.8em;
    }

    @media (max-width: 800px) {
      .layer-indicator {
        font-size: 0.6rem;
        letter-spacing: 0.1em;
        gap: 0.5em;
      }
    }

    @media (max-width: 500px) {
      .layer-indicator {
        flex-direction: column;
        align-items: flex-end;
        gap: 0.25em;
      }
    }

    .layer-name {
      transition: opacity 0.3s;
    }

    .layer-skeleton { color: #666; }
    .layer-blueprint { color: #0ff; }
    .layer-ghost { color: #f44; }
  </style>
</head>
<body>
  <!-- Control Panel -->
  <div class="control-panel">
    <div class="slider-container">
      <label for="reality-index">REALITY_INDEX</label>
      <input type="range" id="reality-index" min="0" max="100" value="0">
      <div class="slider-labels">
        <span>0.0 SKELETON</span>
        <span>0.5 BLUEPRINT</span>
        <span>1.0 GHOST</span>
      </div>
    </div>
    <div class="readout">
      <span class="time">02:47:33</span>
      <span class="location">洗心堂 — Kugayama</span>
    </div>
  </div>

  <!-- Layer Indicator -->
  <div class="layer-indicator">
    <span class="layer-name layer-skeleton">SKELETON</span>
    <span class="layer-name layer-blueprint">BLUEPRINT</span>
    <span class="layer-name layer-ghost">GHOST</span>
  </div>

  <!-- A-Frame Scene -->
  <div class="scene-container">
    <a-scene background="color: #0a0a0a" vr-mode-ui="enabled: false" renderer="antialias: true">

      <!-- Orthographic Camera for isometric view (from left-front corner) -->
      <a-entity id="camera-rig" position="0 0 0">
        <a-entity
          id="main-camera"
          camera="active: true"
          orthographic-camera="zoom: 12"
          position="-8 10 8"
          rotation="-40 -45 0">
        </a-entity>
      </a-entity>

      <!-- Ambient light (brighter) -->
      <a-light type="ambient" color="#606060" intensity="0.8"></a-light>

      <!-- Directional light (from above-front, brighter) -->
      <a-light type="directional" color="#ffffff" intensity="0.8" position="2 4 3"></a-light>

      <!-- Fill light from opposite side -->
      <a-light type="directional" color="#aaaaff" intensity="0.3" position="-3 2 -2"></a-light>


      <!-- Floor -->
      <a-plane
        id="floor"
        position="0 0 0"
        rotation="-90 0 0"
        width="10"
        height="8"
        material="color: #1a1a1a; wireframe: false; opacity: 0.9">
        <!-- Grid lines on floor -->
      </a-plane>

      <!-- Floor grid (wireframe overlay) -->
      <a-plane
        position="0 0.01 0"
        rotation="-90 0 0"
        width="10"
        height="8"
        material="color: #333; wireframe: true; opacity: 0.5">
      </a-plane>

      <!-- Back Wall (North) -->
      <a-plane
        id="wall-north"
        position="0 2 -4"
        width="10"
        height="4"
        material="color: #1a1a1a; opacity: 0.8; side: double">
      </a-plane>

      <!-- Side Wall (East) -->
      <a-plane
        id="wall-east"
        position="5 2 0"
        rotation="0 -90 0"
        width="8"
        height="4"
        material="color: #1a1a1a; opacity: 0.8; side: double">
      </a-plane>

      <!-- Machine #4 -->
      <a-entity id="machine-4" position="-2 0.6 -2" class="clickable" data-id="machine-4">
        <!-- Main body -->
        <a-box
          width="0.8"
          height="1.2"
          depth="0.7"
          material="color: #2a2a2a; opacity: 0.9">
        </a-box>
        <!-- Drum door (circle on front) -->
        <a-circle
          position="0 0 0.351"
          radius="0.3"
          material="color: #0a0a0a; opacity: 0.8">
        </a-circle>
        <!-- Drum glass -->
        <a-circle
          position="0 0 0.352"
          radius="0.25"
          material="color: #1a3a3a; opacity: 0.5">
        </a-circle>
      </a-entity>

      <!-- Chair #2 -->
      <a-entity id="chair-2" position="1 0.25 1" class="clickable" data-id="chair-2">
        <!-- Seat -->
        <a-box
          width="0.45"
          height="0.05"
          depth="0.45"
          material="color: #3a3a3a; opacity: 0.9">
        </a-box>
        <!-- Legs -->
        <a-box position="-0.18 -0.15 -0.18" width="0.04" height="0.25" depth="0.04" material="color: #2a2a2a"></a-box>
        <a-box position="0.18 -0.15 -0.18" width="0.04" height="0.25" depth="0.04" material="color: #2a2a2a"></a-box>
        <a-box position="-0.18 -0.15 0.18" width="0.04" height="0.25" depth="0.04" material="color: #2a2a2a"></a-box>
        <a-box position="0.18 -0.15 0.18" width="0.04" height="0.25" depth="0.04" material="color: #2a2a2a"></a-box>
      </a-entity>

      <!-- Table #3 -->
      <a-entity id="table-3" position="0 0.45 -1" class="clickable" data-id="table-3">
        <!-- Tabletop -->
        <a-box
          width="1.8"
          height="0.05"
          depth="0.6"
          material="color: #3a3a3a; opacity: 0.9">
        </a-box>
        <!-- Legs -->
        <a-box position="-0.8 -0.23 -0.2" width="0.05" height="0.4" depth="0.05" material="color: #2a2a2a"></a-box>
        <a-box position="0.8 -0.23 -0.2" width="0.05" height="0.4" depth="0.05" material="color: #2a2a2a"></a-box>
        <a-box position="-0.8 -0.23 0.2" width="0.05" height="0.4" depth="0.05" material="color: #2a2a2a"></a-box>
        <a-box position="0.8 -0.23 0.2" width="0.05" height="0.4" depth="0.05" material="color: #2a2a2a"></a-box>
      </a-entity>

      <!-- The Figure (thermal phenomenon) -->
      <a-entity id="figure" position="0.3 0 -0.8" class="clickable" data-id="figure">
        <!-- Thermal core - layered glow spheres with additive blending -->
        <a-entity id="thermal-core-group" position="0 0.9 0">
          <!-- Inner core (brightest, white-yellow heat source) -->
          <a-sphere
            id="thermal-core"
            radius="0.06"
            material="color: #ffffcc; opacity: 0; emissive: #ffdd88; emissiveIntensity: 3; transparent: true"
            animation="property: scale; from: 1 1 1; to: 1.15 1.15 1.15; dur: 2000; dir: alternate; loop: true; easing: easeInOutQuad">
          </a-sphere>
          <!-- Middle glow layer (orange transition) -->
          <a-sphere
            id="thermal-mid"
            radius="0.12"
            material="color: #ffaa66; opacity: 0; emissive: #ff8844; emissiveIntensity: 2; transparent: true"
            animation="property: scale; from: 1 1 1; to: 1.2 1.2 1.2; dur: 2500; dir: alternate; loop: true; easing: easeInOutQuad">
          </a-sphere>
          <!-- Outer glow layer (deep red field, renders backside) -->
          <a-sphere
            id="thermal-outer"
            radius="0.22"
            material="color: #ff4422; opacity: 0; emissive: #cc2200; emissiveIntensity: 1; transparent: true"
            animation="property: scale; from: 1 1 1; to: 1.25 1.25 1.25; dur: 3500; dir: alternate; loop: true; easing: easeInOutQuad">
          </a-sphere>
        </a-entity>

        <!-- Pressure field on floor - controlled via JavaScript for visibility sync -->
        <a-ring
          id="pressure-field-1"
          position="0 0.02 0"
          rotation="-90 0 0"
          radius-inner="0.1"
          radius-outer="0.15"
          material="color: #ff6644; opacity: 0; transparent: true; side: double">
        </a-ring>
        <a-ring
          id="pressure-field-2"
          position="0 0.02 0"
          rotation="-90 0 0"
          radius-inner="0.2"
          radius-outer="0.28"
          material="color: #ff4444; opacity: 0; transparent: true; side: double">
        </a-ring>
        <a-ring
          id="pressure-field-3"
          position="0 0.02 0"
          rotation="-90 0 0"
          radius-inner="0.35"
          radius-outer="0.45"
          material="color: #ff2222; opacity: 0; transparent: true; side: double">
        </a-ring>
      </a-entity>

      <!-- Window (in north wall) -->
      <a-entity id="window" position="-3 1.5 -3.95" class="clickable" data-id="window">
        <!-- Frame -->
        <a-box
          width="1.5"
          height="1.2"
          depth="0.1"
          material="color: #2a2a2a">
        </a-box>
        <!-- Glass -->
        <a-plane
          position="0 0 0.051"
          width="1.3"
          height="1"
          material="color: #1a2a3a; opacity: 0.6">
        </a-plane>
        <!-- Vending machine glow (outside) -->
        <a-plane
          position="-0.3 -0.2 -0.1"
          width="0.3"
          height="0.5"
          material="color: #00ffff; opacity: 0.3; emissive: #00ffff; emissiveIntensity: 0.3">
        </a-plane>
      </a-entity>

      <!-- Grey Water Door (in east wall) -->
      <a-entity id="grey-water-door" position="4.95 1 1" rotation="0 -90 0" class="clickable" data-id="grey-water-door">
        <!-- Door frame -->
        <a-box
          width="1"
          height="2"
          depth="0.1"
          material="color: #2a3a3a">
        </a-box>
        <!-- Frosted glass panel -->
        <a-plane
          position="0 0.2 0.051"
          width="0.7"
          height="0.5"
          material="color: #2a4a5a; opacity: 0.7">
        </a-plane>
      </a-entity>

      <!-- Change Machine (against north wall) -->
      <a-entity id="change-machine" position="3 0.7 -3.5" class="clickable" data-id="change-machine">
        <!-- Main body -->
        <a-box
          width="0.6"
          height="1.4"
          depth="0.5"
          material="color: #3a3a3a">
        </a-box>
        <!-- Coin slot -->
        <a-box
          position="0 0.3 0.251"
          width="0.15"
          height="0.02"
          depth="0.02"
          material="color: #1a1a1a">
        </a-box>
        <!-- Dispenser -->
        <a-box
          position="0 -0.4 0.251"
          width="0.2"
          height="0.15"
          depth="0.02"
          material="color: #1a1a1a">
        </a-box>
      </a-entity>

    </a-scene>
  </div>

  <!-- Info Panel -->
  <div class="info-panel" id="info-panel">
    <div class="info-header">
      <span class="info-title">SELECT OBJECT</span>
      <button class="info-close">&times;</button>
    </div>
    <div class="info-content">
      <p class="skeleton-content"></p>
      <p class="blueprint-content"></p>
      <p class="ghost-content"></p>
    </div>
  </div>

  <!-- Resonance text -->
  <div class="resonance" id="resonance">
    <p>The chair remembers the body longer than the body remembers the chair.</p>
  </div>

  <script>
    // Register orthographic camera component
    AFRAME.registerComponent('orthographic-camera', {
      schema: {
        zoom: { type: 'number', default: 12 }
      },
      init: function() {
        const el = this.el;
        const data = this.data;
        const sceneEl = document.querySelector('a-scene');

        // Wait for scene to be fully loaded
        const setupCamera = () => {
          const camera = el.getObject3D('camera');
          if (camera) {
            // Convert to orthographic
            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = data.zoom;

            const orthoCamera = new THREE.OrthographicCamera(
              frustumSize * aspect / -2,
              frustumSize * aspect / 2,
              frustumSize / 2,
              frustumSize / -2,
              0.1,
              1000
            );

            // Copy position and rotation from the entity (not the old camera)
            el.object3D.add(orthoCamera);
            el.setObject3D('camera', orthoCamera);

            // Update scene's camera reference
            sceneEl.camera = orthoCamera;

            // Handle resize
            window.addEventListener('resize', () => {
              const newAspect = window.innerWidth / window.innerHeight;
              orthoCamera.left = frustumSize * newAspect / -2;
              orthoCamera.right = frustumSize * newAspect / 2;
              orthoCamera.updateProjectionMatrix();
            });
          }
        };

        // Try immediately and also on loaded
        if (sceneEl.hasLoaded) {
          setTimeout(setupCamera, 100);
        }
        sceneEl.addEventListener('loaded', () => setTimeout(setupCamera, 100));
      }
    });

    // Content database (global for click handler)
    window.objectContent = {
      'machine-4': {
        skeleton: 'AQUA HCD-3257GC washer-dryer. 1200 RPM extraction. Internal temp 28°C (2°C above ambient). Last cycle: 47 minutes ago.',
        blueprint: 'Processing node in the emotional solvent network. What enters dirty exits clean — but the dirt goes somewhere.',
        ghost: 'This machine runs warmer than the others. The lint trap holds fibers that don\'t match any fabric in the room. Someone\'s grief is still spinning in the drum.'
      },
      'chair-2': {
        skeleton: 'Molded plastic. 45cm seat height. Left side warped 3mm from repeated weight.',
        blueprint: 'Temporal compression site. Where waiting becomes a physical shape. The warp is accumulated patience.',
        ghost: '0.7°C warmer on left side, consistent with 67kg person leaning for approximately 28 minutes. The chair remembers the body longer than the body remembers the chair.'
      },
      'table-3': {
        skeleton: 'Laminate surface, 1.8m × 0.6m. One corner chipped. Thermal anomaly at coordinates (0.4m, 0.3m): 34°C.',
        blueprint: 'Ritual site where personal chaos is pressed into order. The folding is a mandala. The handprint is a prayer.',
        ghost: 'A handprint that isn\'t visible — but the warmth is there. Someone pressed their palm here while deciding something. The gesture repeats in the warmth gradient.'
      },
      'figure': {
        skeleton: 'Human silhouette, approximately 67kg mass, engaged in repetitive motor activity. Cotton-polyester blend fabric.',
        blueprint: 'A temporary node in the gesture-transmission network. They are both laundered and launderer. The fold is a prayer they didn\'t compose.',
        ghost: 'Their hands move with a rhythm learned from someone else. The shirt they\'re folding isn\'t theirs. It smells like a childhood home they can\'t name.'
      },
      'window': {
        skeleton: 'View: Kugayama, Suginami Ward, Tokyo. 35.6847°N, 139.5994°E. Vending machine glow (4200K). Bicycle leaning against fence.',
        blueprint: 'The laundromat is a node in a larger circuit — the night, the neighborhood, the consciousness that contains us. This window is a membrane between worlds.',
        ghost: 'Someone who lives here is dreaming this. Right now. The person who imagined this place into being walks these streets in daylight.'
      },
      'grey-water-door': {
        skeleton: '機械室 (Machine Room). Frosted glass. Grey water reclamation system behind. 300L capacity. Maintains 28°C for bacterial processing.',
        blueprint: 'This is where the laundromat stores what it removes. The emotional solvent. The memory extracted from fabric waits here before being released into the municipal system. Some rooms should stay closed.',
        ghost: 'The air here tastes like borrowed salt. Sometimes, at 3 AM, you can hear it slosh — a rhythm that doesn\'t match the pumps. Something moves in there. Not visually. Thermally.'
      },
      'change-machine': {
        skeleton: '¥1000 note acceptor, ¥100 coin dispenser. Manufactured 2018. Last transaction: 2:31 AM.',
        blueprint: 'The ritual exchange: clean currency for soiled time. The economy of purification. This is where you pay to forget.',
        ghost: 'The last person to use it left a fingerprint on the \'1000\' button. Their pulse was elevated. They stood here counting coins, deciding if the wash was worth it.'
      }
    };

    const resonancePhrases = [
      'What the data misses, the body remembers.',
      'The chair remembers the body longer than the body remembers the chair.',
      'You fold the shirt, but who folded you?',
      'The water leaves, but the memory of water remains.',
      'The measurement shows the weight. The ghost shows why it\'s heavy.',
      'This is not a place where people do laundry. This is a place where laundry does people.',
      'We all have gestures that aren\'t ours.',
      'The grey water holds what we paid to forget.'
    ];

    // State
    let currentReality = 0;
    let isTransitioning = false;
    let selectedObject = null;

    // DOM Elements
    const slider = document.getElementById('reality-index');
    const infoPanel = document.getElementById('info-panel');
    const resonanceEl = document.getElementById('resonance');

    // A-Frame elements (after scene loads)
    let thermalCore, thermalMid, thermalOuter;
    let pressureField1, pressureField2, pressureField3;

    // Wait for A-Frame to load
    document.querySelector('a-scene').addEventListener('loaded', () => {
      thermalCore = document.getElementById('thermal-core');
      thermalMid = document.getElementById('thermal-mid');
      thermalOuter = document.getElementById('thermal-outer');
      pressureField1 = document.getElementById('pressure-field-1');
      pressureField2 = document.getElementById('pressure-field-2');
      pressureField3 = document.getElementById('pressure-field-3');

      // Apply additive blending to thermal spheres (the "add the light" technique)
      // This is the WebGL equivalent of mix-blend-mode: lighten
      // Use robust timing: wait for render loop to ensure materials exist
      const applyAdditiveBlending = () => {
        let applied = false;
        [thermalCore, thermalMid, thermalOuter].forEach(el => {
          if (el) {
            el.object3D.traverse((child) => {
              if (child.isMesh && child.material) {
                child.material.blending = THREE.AdditiveBlending;
                child.material.depthWrite = false;
                applied = true;
              }
            });
          }
        });

        // Outer sphere renders inside (backside) for softer look
        if (thermalOuter) {
          thermalOuter.object3D.traverse((child) => {
            if (child.isMesh && child.material) {
              child.material.side = THREE.BackSide;
            }
          });
        }

        // If materials weren't ready, try again
        if (!applied) {
          requestAnimationFrame(applyAdditiveBlending);
        }
      };

      // Start trying after a frame
      requestAnimationFrame(() => {
        requestAnimationFrame(applyAdditiveBlending);
      });

      const sceneEl = document.querySelector('a-scene');
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();

      // Get all clickable meshes
      const getClickableMeshes = () => {
        const meshes = [];
        document.querySelectorAll('.clickable').forEach(el => {
          el.object3D.traverse((child) => {
            if (child.isMesh) {
              child.userData.entityId = el.getAttribute('data-id') || el.id;
              meshes.push(child);
            }
          });
        });
        return meshes;
      };

      // Handle mouse clicks with Three.js raycaster
      sceneEl.canvas.addEventListener('click', (event) => {
        const rect = sceneEl.canvas.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        const camera = sceneEl.camera;
        if (!camera) return;

        raycaster.setFromCamera(mouse, camera);
        const meshes = getClickableMeshes();
        const intersects = raycaster.intersectObjects(meshes, false);

        if (intersects.length > 0) {
          const id = intersects[0].object.userData.entityId;
          if (id && window.objectContent[id]) {
            window.handleObjectClick(id);
          }
        }
      });

      // Initial state
      updateReality(0);
    });

    // Slider control
    slider.addEventListener('input', (e) => {
      const value = e.target.value / 100;

      if (!isTransitioning && Math.abs(value - currentReality) > 0.1) {
        showResonance();
      }

      currentReality = value;
      updateReality(value);
    });

    // Update everything based on reality index
    function updateReality(value) {
      document.documentElement.style.setProperty('--reality', value);

      // Update thermal phenomenon visibility (layered glow)
      // Only visible in Ghost mode (value > 0.5), peak at 1.0
      const thermalVisibility = Math.max(0, (value - 0.4) * 1.67); // 0 at 0.4, 1 at 1.0

      if (thermalCore) {
        thermalCore.setAttribute('material', 'opacity', thermalVisibility * 0.9);
        thermalCore.setAttribute('material', 'emissiveIntensity', thermalVisibility * 3);
      }
      if (thermalMid) {
        thermalMid.setAttribute('material', 'opacity', thermalVisibility * 0.5);
        thermalMid.setAttribute('material', 'emissiveIntensity', thermalVisibility * 2);
      }
      if (thermalOuter) {
        thermalOuter.setAttribute('material', 'opacity', thermalVisibility * 0.25);
        thermalOuter.setAttribute('material', 'emissiveIntensity', thermalVisibility * 1);
      }

      // Pressure ripples - static concentric rings, fade in with thermal
      if (pressureField1) {
        pressureField1.setAttribute('material', 'opacity', thermalVisibility * 0.4);
      }
      if (pressureField2) {
        pressureField2.setAttribute('material', 'opacity', thermalVisibility * 0.25);
      }
      if (pressureField3) {
        pressureField3.setAttribute('material', 'opacity', thermalVisibility * 0.15);
      }

      // Update layer indicator
      document.querySelector('.layer-skeleton').style.opacity = 1 - value;
      document.querySelector('.layer-blueprint').style.opacity = 1 - Math.abs(value - 0.5) * 2;
      document.querySelector('.layer-ghost').style.opacity = value;

      // Update materials based on reality index
      updateMaterials(value);

      // Update info panel if open
      if (selectedObject) {
        updatePanelContent(selectedObject);
      }
    }

    // Update object materials based on reality index
    function updateMaterials(value) {
      // Skeleton (0): grey wireframe, transparent fill
      // Blueprint (0.5): cyan tint, solid
      // Ghost (1.0): warm, slight glow

      // SKELETON: brighter grey-green for visibility against dark background
      const skeletonColor = { r: 0.4, g: 0.5, b: 0.45 };
      const blueprintColor = { r: 0.1, g: 0.6, b: 0.7 };
      const ghostColor = { r: 0.6, g: 0.2, b: 0.2 };

      // Interpolate colors
      let color;
      if (value < 0.5) {
        const t = value * 2;
        color = {
          r: skeletonColor.r + (blueprintColor.r - skeletonColor.r) * t,
          g: skeletonColor.g + (blueprintColor.g - skeletonColor.g) * t,
          b: skeletonColor.b + (blueprintColor.b - skeletonColor.b) * t
        };
      } else {
        const t = (value - 0.5) * 2;
        color = {
          r: blueprintColor.r + (ghostColor.r - blueprintColor.r) * t,
          g: blueprintColor.g + (ghostColor.g - blueprintColor.g) * t,
          b: blueprintColor.b + (ghostColor.b - blueprintColor.b) * t
        };
      }

      const colorHex = '#' +
        Math.round(color.r * 255).toString(16).padStart(2, '0') +
        Math.round(color.g * 255).toString(16).padStart(2, '0') +
        Math.round(color.b * 255).toString(16).padStart(2, '0');

      // Smooth transition: wireframe fades out as fill fades in
      // 0.0-0.15: pure wireframe
      // 0.15-0.4: transition zone (wireframe fades, fill appears)
      // 0.4+: solid fill
      const wireframe = value < 0.3;

      // Opacity: SKELETON mode more visible
      // 0.0-0.2: wireframe clearly visible (opacity 0.6-0.7)
      // 0.2-0.4: transition to solid (opacity 0.7-1.0)
      // 0.4+: full solid (opacity 1.0)
      let opacity;
      if (value < 0.2) {
        opacity = 0.6 + value * 0.5; // 0.6 to 0.7
      } else if (value < 0.4) {
        opacity = 0.7 + (value - 0.2) * 1.5; // 0.7 to 1.0
      } else {
        opacity = 1.0;
      }

      // Apply to clickable objects (except the figure - it has special thermal materials)
      document.querySelectorAll('.clickable').forEach(el => {
        // Skip the figure entity - its thermal spheres have custom additive blending
        if (el.id === 'figure') return;

        el.object3D.traverse((child) => {
          if (child.isMesh && child.material) {
            child.material.color.setStyle(colorHex);
            child.material.wireframe = wireframe;
            child.material.wireframeLinewidth = 2; // Thicker lines (may not work on all platforms)

            // Set opacity for smooth fill transition
            child.material.transparent = true;
            child.material.opacity = opacity;

            // Add emissive glow in ghost mode
            if (child.material.emissive) {
              const glowIntensity = Math.max(0, (value - 0.7) * 3);
              child.material.emissive.setStyle('#ff4444');
              child.material.emissiveIntensity = glowIntensity * 0.3;
            }
          }
        });
      });

      // Update walls with same transitions
      const wallNorth = document.getElementById('wall-north');
      const wallEast = document.getElementById('wall-east');
      [wallNorth, wallEast].forEach(wall => {
        if (wall) {
          wall.setAttribute('material', 'color', colorHex);
          wall.setAttribute('material', 'wireframe', wireframe);
          wall.setAttribute('material', 'opacity', opacity);
        }
      });
    }

    window.handleObjectClick = function(id) {
      selectedObject = id;
      updatePanelContent(id);
      openPanel();
    }

    function updatePanelContent(id) {
      const content = window.objectContent[id];
      if (!content) return;

      document.querySelector('.info-title').textContent = id.toUpperCase().replace(/-/g, ' ');
      document.querySelector('.skeleton-content').textContent = content.skeleton;
      document.querySelector('.blueprint-content').textContent = content.blueprint;
      document.querySelector('.ghost-content').textContent = content.ghost;
    }

    function openPanel() {
      infoPanel.classList.add('open');
    }

    document.querySelector('.info-close').addEventListener('click', () => {
      infoPanel.classList.remove('open');
      selectedObject = null;
    });

    function showResonance() {
      if (isTransitioning) return;

      isTransitioning = true;
      const phrase = resonancePhrases[Math.floor(Math.random() * resonancePhrases.length)];
      resonanceEl.querySelector('p').textContent = phrase;
      resonanceEl.classList.add('visible');

      setTimeout(() => {
        resonanceEl.classList.remove('visible');
        isTransitioning = false;
      }, 3000);
    }

    // Update time display
    function updateTime() {
      const now = new Date();
      const seconds = now.getSeconds().toString().padStart(2, '0');
      document.querySelector('.time').textContent = `02:47:${seconds}`;
    }
    updateTime();
    setInterval(updateTime, 1000);
  </script>
</body>
</html>
